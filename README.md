## 概要
<p>
  三角形メッシュを用いた衝突判定を行うパストレーシングとNEEによるレンダリング。また、それらを多重重点的サンプリングにて組み合わせた手法を提供する。
  いずれは双方向パストレーシングの実装を目指している。
  3Dシーンはobjファイルにて読み込んでいるが、光源、カメラについてはmain.cpp内で記述されている。
</p>

<br>

## 前提知識
### レンダリングとは
<p>CG分野におけるレンダリングとは3Dシーン、光源情報、カメラ情報を入力として2D画像を生成する処理のことを指す。</p>

<br>
<p align="center">
  <img src="https://github.com/user-attachments/assets/3e66ce3b-a197-46f9-9762-546c33d1bc4c"><br>
  レンダリングのイメージ図
</p>
<br>
  
### レンダリング方程式
<p>
  レンダリングでは光源から放射された光が、3Dシーン上で反射、屈折し、視点に入射するまでの様子をシミュレーションすることで画像を生成する。
  ここで計算される値は放射輝度と呼ばれる、光線の強度(明るさ)を表す物理量であり、Kajiyaらによって以下の様に定式化された[1]。
</p>

$$
 L_o(x, \omega_o) = L_e(x, \omega_o) + \int_\Omega f_r(x, \omega_i, \omega_o) L_i(x, \omega_i) (\omega_i \cdot n) d\omega_i
$$

<p>
  しかし、上記の積分式は解析的に計算することができないため、コンピュータを使って数値的に計算を行っていく。
  レンダリング方程式で扱う積分式は高次元であるため、次元に依存しない積分推定が行えるモンテカルロ積分が一般的に利用される。
</p>

### モンテカルロ積分
<p>モンテカルロ積分は確率論に基づいて積分を行う手法である。  
  $X$という確率変数が確率密度関数 $p(x)$ によって集合 $\Omega$ の任意の値を取る場合、 $X$ の期待値 $E[X]$ は下記の様に表される。
</p>

$$E[X] = \int_{\Omega} xp(x)dx$$

<p>
  これは解析的に期待値を計算する方法であり、サイコロの期待値を計算する $E[X] = \frac{1}{6}(1 + 2 + 3 + 4 + 5 + 6) = 3.5$ という計算を表している(確率変数の分布が離散型か連続型かの違いはある)。
  一方で、サイコロの期待値を求める方法はもう一つ、実験的に算出する方法がある。サイコロを実際に $N$ 回振り、その出目の平均を取る方法である。各試行で得られる値を $x_i$ とすると、 $E[x_i] = E[X]$ が満たされるため、出目の平均の期待値についても解析的に算出した期待値 $E[X]$ と一致する。
</p>

$$E[\frac{1}{N}\sum_{i=1}^{N} X_i] = E[X]$$

<p>
  大数の強法則により、試行回数 $N$ が無限大に近づくにつれ、上記の左辺は右辺の $E[X]$ へと収束していく。  
  ここで伝えたいことは期待値 $E[X]$ を用いることで、積分を数値的に計算できるということである。具体的には下記の式変形を加える。
</p>

$$\int_{\Omega}f(x)dx = \int_{\Omega}\frac{f(x)}{p(x)}p(x)dx$$
$$\int_{\Omega}f(x)dx \approx \frac{1}{N}\sum_{i=1}^{N}\frac{f(X_i)}{f(X_i)}$$

<p>
  この式変形により、先ほどのレンダリング方程式の被積分関数を、確率密度関数で割り、 $N$ 回の平均を取ることで積分値を推定できる。
  ここで、確率密度関数 $p(\omega_i)$ は設計者が自由に決めることができるが、モンテカルロ推定では、確率密度関数を被積分関数に比例させるようにとることで分散を小さくすることができるため、適切な確率密度関数を取ることが非常に重要である。
</p>

### 光輸送アルゴリズムについて
- Path Tracing
  <p>
    光輸送アルゴリズムは先ほどのレンダリング方程式と組み合わせて用いる手法であり、KajiyaによってPath Tracingが提案された。
    現実世界では、光源から発せられた光が視点に入射することで、物体を視覚することができるが、光源から発せられた光の内、視点に入射するものはごくわずかであるため、Path Tracingでは視点側から光路を追跡していくことで放射輝度の計算を行う手法である。
    </p>

  <br>
  <p align="center">
    <img src="https://github.com/user-attachments/assets/c585c1e6-f93f-4b15-b208-93b66e20213d"><br>
    Path Tracingによる光路生成イメージ
  </p>
  <br>

- Next Event Estimation
  <p>
    Path Tracingでは、視点側から物体を追跡していくため、小さい光源のシーンなどでは、視点と光源を結ぶ光路を生成することが難しく、計算効率が悪くなってしまう。
    そのため、物体との衝突ごとに、衝突点と光源を接続することで、視点側からでは中々光源につながらないようなシーンでも光路を生成することが可能となった。
    この手法をNext Event Estimation(NEE)と呼ぶ。
  </p>

  <br>
  <p align="center">
    <img src="https://github.com/user-attachments/assets/a010264f-6710-4a1a-981e-361337862a55"><br>
    NEEによる光路生成イメージ
  </p>
  <br>

<br>
<p>
  これらの光輸送アルゴリズムには、得意、不得意なシーンが存在する。そのため、複数の手法を組み合わせることで、より複雑な光学効果が表れるシーンへの対応を図る多重重点的サンプリングと呼ばれる手法がVeachらによって提案された[2]。  
  多重重点的サンプリングではMISウエイトと呼ばれる重みを用いることで、複数の手法を組み合わせる。
</p>

### 引用論文
[1] [Kajiya1986] James T. Kajiya - "THE RENDERING EQUATION", 1986  
[2] [Veach1998] Eric Veach, Leonidas J. Guibas - "ROBUST MONTE CARLO METHODS FOR LIGHT TRANSPORT SIMULATION", 1998

<br>

## レンダリング画像
パストレーシングと、多重重点的サンプリングを用いた手法で同一シーンをレンダリングした結果について示す。反射はLambertモデルと、Blinn Phongモデルを使用可能だが、下記の画像はすべてLambert反射を使用したものである。

<br>
<p align="center">
  <img src="https://github.com/CGLkousei/basic_rendering/assets/147574806/b667192b-2ca9-4ed4-a178-4cca594215a2 "パストレーシングでのレンダリング""><br>
  Path Tracingを使用したレンダリング結果
</p>
<br>

<p align="center">
  <img src="https://github.com/CGLkousei/basic_rendering/assets/147574806/d512c4b3-550c-4279-a4b9-717455fc1353 "多重重点的サンプリングを用いたレンダリング""><br>
  MISウエイトを用いてNEE, Path Tracingを組み合わせた結果
</p>
<br>

## 使用しているライブラリ
* Eigen3
* OpenGL
* OpenCV
* FreeGLUT

## それぞれのプログラムの役割
| クラス名      | 役割                            |
|-----------|-------------------------------|
| Camera    | 入力として得たカメラに関する情報を保持           |
| Color     | RGB値で輝度を管理                    |
| GLPreview | OpenGLで行う初期設定などを管理            |
| Image     | 生成したレンダリング結果を画像出力する           |
| JPEG      | 画像入力等をする際に使用するが、本プログラムでは利用しない |
| Light     | 入力として得た高原に関する情報を保持            |
| random    | モンテカルロ積分で使用する乱数を管理            |
| Renderer  | パストレーシング、NEEといったレンダリング処理を管理   |
| TriMesh   | 入力された3Dシーンを管理                 |
